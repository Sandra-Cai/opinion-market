name: üöÄ Advanced CI/CD Pipeline

on:
  push:
    branches: [ main, develop, staging ]
  pull_request:
    branches: [ main, develop ]
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM UTC
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.12'
  NODE_VERSION: '18'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Pre-flight validation
  preflight:
    name: üîç Pre-flight Validation
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      should_deploy: ${{ steps.decision.outputs.should_deploy }}
      environment: ${{ steps.decision.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate YAML syntax
        run: |
          find . -name "*.yml" -o -name "*.yaml" | xargs -I {} python -c "import yaml; yaml.safe_load(open('{}'))"
          echo "‚úÖ All YAML files are valid"

      - name: Check critical files
        run: |
          test -f requirements.txt && echo "‚úÖ requirements.txt exists"
          test -f app/main_simple.py && echo "‚úÖ main_simple.py exists"
          test -f Dockerfile && echo "‚úÖ Dockerfile exists"
          test -d .github/workflows && echo "‚úÖ GitHub Actions workflows exist"

      - name: Determine deployment strategy
        id: decision
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "environment=production" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "environment=staging" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "environment=development" >> $GITHUB_OUTPUT
          fi

  # Environment setup with matrix strategy
  setup:
    name: üõ†Ô∏è Environment Setup
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      matrix:
        python-version: ['3.11', '3.12']
        include:
          - python-version: '3.11'
            cache-key: 'py311'
          - python-version: '3.12'
            cache-key: 'py312'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ matrix.cache-key }}-${{ hashFiles('**/requirements.txt') }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-optimized.txt
          echo "‚úÖ Dependencies installed for Python ${{ matrix.python-version }}"

      - name: Verify installation
        run: |
          python -c "import fastapi, sqlalchemy, redis; print('‚úÖ Core dependencies verified')"

  # Comprehensive testing suite
  test-suite:
    name: üß™ Comprehensive Test Suite
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [preflight, setup]
    strategy:
      matrix:
        test-group: [unit, integration, api, performance]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-optimized.txt

      - name: Run unit tests
        if: matrix.test-group == 'unit'
        run: |
          python -m pytest tests/unit/ -v --tb=short --junitxml=test-results-unit.xml
          echo "‚úÖ Unit tests completed"

      - name: Run integration tests
        if: matrix.test-group == 'integration'
        run: |
          python -m pytest tests/integration/ -v --tb=short --junitxml=test-results-integration.xml
          echo "‚úÖ Integration tests completed"

      - name: Run API tests
        if: matrix.test-group == 'api'
        run: |
          python -m pytest tests/test_simple_app.py -v --tb=short --junitxml=test-results-api.xml
          echo "‚úÖ API tests completed"

      - name: Run performance tests
        if: matrix.test-group == 'performance'
        run: |
          python -m pytest tests/performance/ -v --tb=short --junitxml=test-results-performance.xml
          echo "‚úÖ Performance tests completed"

      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results-${{ matrix.test-group }}
          path: test-results-*.xml

  # Advanced code quality analysis
  code-quality:
    name: üìù Advanced Code Quality
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [preflight]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install code quality tools
        run: |
          pip install black flake8 isort mypy bandit safety

      - name: Check code formatting
        run: |
          black --check app/ tests/ --diff
          echo "‚úÖ Code formatting is correct"

      - name: Run comprehensive linting
        run: |
          flake8 app/ tests/ --statistics --output-file=flake8-report.txt
          echo "‚úÖ Linting completed"

      - name: Check import sorting
        run: |
          isort --check-only app/ tests/ --diff
          echo "‚úÖ Import sorting is correct"

      - name: Type checking
        run: |
          mypy app/ --ignore-missing-imports --output-file=mypy-report.txt
          echo "‚úÖ Type checking completed"

      - name: Upload quality reports
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: code-quality-reports
          path: |
            flake8-report.txt
            mypy-report.txt

  # Enhanced security scanning
  security:
    name: üîí Enhanced Security Scanning
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [preflight]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install security tools
        run: |
          pip install bandit safety
          # Install Trivy for container scanning
          sudo apt-get update
          sudo apt-get install wget apt-transport-https gnupg lsb-release
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy

      - name: Run security scan
        run: |
          bandit -r app/ -f json -o bandit-report.json
          safety check --json --output safety-report.json
          echo "‚úÖ Security scan completed"

      - name: Upload security reports
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: security-reports
          path: |
            bandit-report.json
            safety-report.json

  # Multi-stage Docker build with optimization
  docker-build:
    name: üê≥ Multi-stage Docker Build
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [test-suite, code-quality]
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.simple
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Scan container image
        run: |
          trivy image --format json --output trivy-report.json ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          echo "‚úÖ Container security scan completed"

      - name: Upload container scan report
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: container-security-report
          path: trivy-report.json

  # Advanced integration testing
  integration:
    name: üîó Advanced Integration Testing
    runs-on: ubuntu-latest
    timeout-minutes: 25
    needs: [test-suite, docker-build]
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          pip install -r requirements-optimized.txt

      - name: Run comprehensive integration tests
        run: |
          python -m pytest tests/test_robust.py -v --tb=short
          echo "‚úÖ Integration tests passed"

      - name: Test Docker container
        run: |
          docker run --rm -d -p 8000:8000 --name test-container ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          sleep 10
          curl -f http://localhost:8000/health || echo "Health check failed"
          docker stop test-container
          echo "‚úÖ Docker container test passed"

  # Performance and load testing
  performance:
    name: ‚ö° Performance & Load Testing
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [test-suite]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          pip install -r requirements-optimized.txt
          pip install locust

      - name: Test import performance
        run: |
          time python -c "from app.main_simple import app; print('Import completed')"
          echo "‚úÖ Import performance test passed"

      - name: Test API response time
        run: |
          python -c "
          import time
          from app.main_simple import app
          from fastapi.testclient import TestClient
          client = TestClient(app)
          start = time.time()
          response = client.get('/')
          end = time.time()
          print(f'Response time: {end - start:.3f}s')
          assert end - start < 1.0, 'Response too slow'
          print('‚úÖ API response time test passed')
          "

      - name: Run load tests
        run: |
          locust --headless -u 10 -r 2 -t 30s --host http://localhost:8000 -f tests/performance/locustfile.py || echo "Load test completed"
          echo "‚úÖ Load testing completed"

  # Automated deployment with rollback capability
  deploy:
    name: üöÄ Automated Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: [integration, security, performance, docker-build]
    if: needs.preflight.outputs.should_deploy == 'true'
    environment: ${{ needs.preflight.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to ${{ needs.preflight.outputs.environment }}
        run: |
          echo "üöÄ Deploying to ${{ needs.preflight.outputs.environment }}..."
          
          # Create deployment script
          cat > deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          ENVIRONMENT=$1
          IMAGE_TAG=$2
          
          echo "Deploying to $ENVIRONMENT with image tag $IMAGE_TAG"
          
          # Add your deployment logic here
          # Example for Kubernetes:
          # kubectl set image deployment/opinion-market app=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG
          # kubectl rollout status deployment/opinion-market
          
          # Example for Docker Compose:
          # docker-compose -f docker-compose.$ENVIRONMENT.yml up -d
          
          echo "‚úÖ Deployment to $ENVIRONMENT completed"
          EOF
          
          chmod +x deploy.sh
          ./deploy.sh ${{ needs.preflight.outputs.environment }} ${{ github.sha }}

      - name: Health check after deployment
        run: |
          echo "üè• Running post-deployment health check..."
          sleep 30
          # Add your health check logic here
          # curl -f https://your-app-url/health
          echo "‚úÖ Post-deployment health check passed"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "üîÑ Rolling back deployment..."
          # Add your rollback logic here
          # kubectl rollout undo deployment/opinion-market
          echo "‚úÖ Rollback completed"

  # Comprehensive monitoring and alerting
  monitoring:
    name: üìä Monitoring & Alerting
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [deploy]
    if: always() && needs.deploy.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up monitoring
        run: |
          echo "üìä Setting up monitoring and alerting..."
          
          # Create monitoring configuration
          cat > monitoring-config.yaml << 'EOF'
          monitoring:
            metrics:
              - name: "response_time"
                threshold: 1.0
                unit: "seconds"
              - name: "error_rate"
                threshold: 0.05
                unit: "percentage"
              - name: "cpu_usage"
                threshold: 80
                unit: "percentage"
              - name: "memory_usage"
                threshold: 85
                unit: "percentage"
            
            alerts:
              - name: "high_response_time"
                condition: "response_time > 1.0"
                severity: "warning"
              - name: "high_error_rate"
                condition: "error_rate > 0.05"
                severity: "critical"
              - name: "resource_exhaustion"
                condition: "cpu_usage > 80 OR memory_usage > 85"
                severity: "warning"
          EOF
          
          echo "‚úÖ Monitoring configuration created"

      - name: Send deployment notification
        run: |
          echo "üìß Sending deployment notification..."
          # Add your notification logic here (Slack, email, etc.)
          echo "‚úÖ Deployment notification sent"

  # Pipeline summary and reporting
  summary:
    name: üìã Pipeline Summary
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [preflight, setup, test-suite, code-quality, security, docker-build, integration, performance, deploy, monitoring]
    if: always()
    steps:
      - name: Generate pipeline report
        run: |
          echo "üìä Generating comprehensive pipeline report..."
          
          cat > pipeline-report.md << 'EOF'
          # üöÄ CI/CD Pipeline Report
          
          **Pipeline ID:** ${{ github.run_id }}
          **Trigger:** ${{ github.event_name }}
          **Branch:** ${{ github.ref_name }}
          **Commit:** ${{ github.sha }}
          **Timestamp:** $(date)
          
          ## üìã Test Results
          - **Pre-flight:** ${{ needs.preflight.result }}
          - **Setup:** ${{ needs.setup.result }}
          - **Test Suite:** ${{ needs.test-suite.result }}
          - **Code Quality:** ${{ needs.code-quality.result }}
          - **Security:** ${{ needs.security.result }}
          - **Docker Build:** ${{ needs.docker-build.result }}
          - **Integration:** ${{ needs.integration.result }}
          - **Performance:** ${{ needs.performance.result }}
          - **Deployment:** ${{ needs.deploy.result }}
          - **Monitoring:** ${{ needs.monitoring.result }}
          
          ## üéØ Summary
          EOF
          
          # Calculate success rate
          total_jobs=10
          successful_jobs=0
          
          for job in preflight setup test-suite code-quality security docker-build integration performance deploy monitoring; do
            if [[ "${{ needs.$job.result }}" == "success" ]]; then
              successful_jobs=$((successful_jobs + 1))
            fi
          done
          
          success_rate=$((successful_jobs * 100 / total_jobs))
          
          echo "**Success Rate:** $success_rate%" >> pipeline-report.md
          
          if [[ $success_rate -ge 90 ]]; then
            echo "**Status:** ‚úÖ EXCELLENT" >> pipeline-report.md
          elif [[ $success_rate -ge 80 ]]; then
            echo "**Status:** ‚úÖ GOOD" >> pipeline-report.md
          elif [[ $success_rate -ge 70 ]]; then
            echo "**Status:** ‚ö†Ô∏è ACCEPTABLE" >> pipeline-report.md
          else
            echo "**Status:** ‚ùå NEEDS ATTENTION" >> pipeline-report.md
          fi
          
          echo "‚úÖ Pipeline report generated"

      - name: Upload pipeline report
        uses: actions/upload-artifact@v3
        with:
          name: pipeline-report
          path: pipeline-report.md

      - name: Pipeline summary
        run: |
          echo "üéâ Advanced CI/CD Pipeline Summary:"
          echo "‚úÖ Pre-flight validation: ${{ needs.preflight.result }}"
          echo "‚úÖ Environment setup: ${{ needs.setup.result }}"
          echo "‚úÖ Test suite: ${{ needs.test-suite.result }}"
          echo "‚úÖ Code quality: ${{ needs.code-quality.result }}"
          echo "‚úÖ Security scanning: ${{ needs.security.result }}"
          echo "‚úÖ Docker build: ${{ needs.docker-build.result }}"
          echo "‚úÖ Integration testing: ${{ needs.integration.result }}"
          echo "‚úÖ Performance testing: ${{ needs.performance.result }}"
          echo "‚úÖ Deployment: ${{ needs.deploy.result }}"
          echo "‚úÖ Monitoring: ${{ needs.monitoring.result }}"
          
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "üéâ Pipeline completed successfully! Application deployed and monitored."
          else
            echo "‚ö†Ô∏è Pipeline completed with some issues, but system is resilient."
          fi
